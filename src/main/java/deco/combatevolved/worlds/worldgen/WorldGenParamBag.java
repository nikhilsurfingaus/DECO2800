package deco.combatevolved.worlds.worldgen;

import deco.combatevolved.exceptions.IllegalWorldSizeException;
import deco.combatevolved.exceptions.InvalidScaleException;
import deco.combatevolved.exceptions.WorldException;
import deco.combatevolved.exceptions.WorldGenException;
import deco.combatevolved.util.worldgen.VoronoiPoint;
import deco.combatevolved.worlds.Tile;
import deco.combatevolved.worlds.biomes.BiomeType;
import java.util.EnumMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * ParamBag class to house all the parameters needed for a world
 */
public class WorldGenParamBag {
    // 2D array to store the height values generated by the perlin noise
    private float[][] heightMap;

    // The array used to store all the points generated by the Voronoi
    // algorithm
    private static VoronoiPoint[] points;

    // The width of the map
    private int mapWidth;

    // The height of the map
    private int mapHeight;

    // The scale used in the Perlin noise generation
    private float noiseScale;

    // The number of octaves to iterate through to create unique Perlin noise
    private int octaves;

    // A multiplier that determines how quickly the amplitudes diminish for
    // each successive octave in a Perlin-noise function.
    private float persistence;

    // A multiplier that determines how quickly the frequency increases for
    // each successive octave in a Perlin-noise function.
    private float lacunarity;

    // Enum map containing the max height each biome is allowed to exist in
    private Map<BiomeType, Float> biomeHeightMap;

    // Enum map containing the max moisture each biome is allowed to have
    private Map<BiomeType, Float> biomeMoistureMap;

    // Seed used for world gen
    private int seed;

    // The side length/2 if the world, (worldSize * 2)^2 to get the number of
    // tiles
    private int worldSize;

    // Biomes size
    private int biomeSize;

    // Param for tuning ocean Quantity
    // 0 <= oceanQuantity <= 1
    private float oceanQuantity;

    // HashMap to store all biomes with a list of Tiles in that biome
    // This variable is the global map of all the tiles in the game and which
    // biome they belong to. When accessing, deleting, storing, modifying
    // Tiles in the game, use this map.
    private ConcurrentHashMap<BiomeType, CopyOnWriteArrayList<Tile>> mapOfTilesInBiomes;

    /**
     * Get's the seed used for this world
     * @return the seed of this world
     */
    public int getSeed() {
        return this.seed;
    }

    /**
     * Set's the seed for this world
     * @param seed the new seed value for this world
     */
    public void setSeed(int seed) throws WorldGenException {
        if (seed <= 0) {
            throw new WorldGenException("Seed cannot be less than or equal to" +
                    " zero");
        }
        this.seed = seed;
    }

    /**
     * Get's the size of this world
     * @return the size of this world
     */
    public int getWorldSize() {
        return this.worldSize;
    }

    /**
     * Set's the new size of the world
     * @param worldSize the value the world size will be set to
     */
    public void setWorldSize(int worldSize) throws IllegalWorldSizeException {
        if (worldSize < 14) {
            throw new IllegalWorldSizeException("World radius must be " +
                    "greater than 14");
        }
        this.worldSize = worldSize;
    }

//    TODO: Luke to update this javadoc
    /**
     * Get's the size of biomes in this world
     * @return the size of biomes in this world
     */
    public float getOceanQuantity() {
        return this.oceanQuantity;
    }

    /**
     * Set's the tuning parameter for how much ocean will be generated
     * @param oceanQuantity The turning parameter for oceany-ness: 0 <= oceanQuantity <= 1
     * @throws WorldGenException Value not in required bounds
     */
    public void setOceanQuantity(float oceanQuantity) throws WorldGenException {
        if (oceanQuantity < 0 || oceanQuantity > 1) {
            throw new WorldGenException("Ocean Quantity tuning parameter must be < 0 or > 1");
        }
        this.oceanQuantity = oceanQuantity;
    }

    /**
     * Get's the size of biomes in this world
     * @return the size of biomes in this world
     */
    public int getBiomeSize() {
        return this.biomeSize;
    }

    /**
     * Set's the size of the corresponding biome
     * @param biomeSize a list of biome sizes for each biome
     */
    public void setBiomeSize(int biomeSize) throws WorldGenException {
        if (biomeSize <=0 ) {
            throw new WorldGenException("Biome size cannot be less than or " +
                    "equal to zero");
        }
        this.biomeSize = biomeSize;
    }

    /**
     * Initialises the heightMap with the dimensions provided
     * @param xValueToInitialise The width of the height map
     * @param yValueToInitialise The height of the height map
     */
    public void initialiseHeightMap(int xValueToInitialise, int yValueToInitialise) {
        this.heightMap = new float[xValueToInitialise][yValueToInitialise];
    }

    /**
     * Get's the current heightMap for the world
     * @return The current heightMap of the world
     */
    public float[][] getHeightMap() {
        return this.heightMap;
    }

    /**
     * Set's the heightMap for the world with new values generated using
     * Perlin noise
     * @param heightMap The new heightMap to set for the world
     */
    public void setHeightMap(float[][] heightMap) {
        this.heightMap = heightMap;
    }

    /**
     * Set's the points generated by the Voronoi algorithm for the world
     * @param voronoiPoints An array of Voronoi points to set for the world
     */
    public static void setVoronoiPoints(VoronoiPoint[] voronoiPoints) {
        points = voronoiPoints;
    }

    /**
     * Get's the array of of VoronoiPoints for the world
     * @return The VoronoiPoints for the world
     */
    public VoronoiPoint[] getVoronoiPoints() {
        return points;
    }

    /**
     * Get's the width of the map for the world
     * @return The width of the map
     */
    public int getMapWidth() {
        return mapWidth;
    }

    /**
     * Set's the width of the map
     * @param mapWidth The width to set the map to
     * @throws WorldException If the passed width is less than the size
     * of the world
     */
    public void setMapWidth(int mapWidth) throws WorldException {
        if (mapWidth < getWorldSize()) {
            throw new WorldException("Map width cannot be less than the world" +
                    " size");
        }
        this.mapWidth = mapWidth;
    }

    /**
     * Get's the height of the map for the world
     * @return The height of the map
     */
    public int getMapHeight() {
        return mapHeight;
    }

    /**
     * Set's the height of the map
     * @param mapHeight The height to set the map to
     * @throws WorldException If the passed height is less than the size of
     * the world
     */
    public void setMapHeight(int mapHeight) throws WorldException {
        if (mapHeight < getWorldSize()) {
            throw new WorldException("Map width cannot be less than the world" +
                    " size");
        }
        this.mapHeight = mapHeight;
    }

    /**
     * Get the noise scale used in the Perlin noise algorithm
     * @return The noise scale used in the world creation
     */
    public float getNoiseScale() {
        return this.noiseScale;
    }

    /**
     * Set's the noise scale for the Perlin noise algorithm
     * @param noiseScale The noise scale used to create Perlin noise values
     * @throws InvalidScaleException If the noiseScale is less than or equal
     * to zero
     */
    public void setNoiseScale(Float noiseScale) throws InvalidScaleException {
        if (noiseScale.equals(0f) || noiseScale < 0) {
            throw new InvalidScaleException("Scale cannot be less than or equal " +
                    "to zero");
        }
        this.noiseScale = noiseScale;
    }

    /**
     * Get's the octaves used in the Perlin noise algorithm
     * @return The number of octaves for the Perlin noise algorithm
     */
    public int getOctaves() {
        return octaves;
    }

    /**
     * Set's the number of octaves for the Perlin noise algorithm
     * @param octaves The number of octaves for the Perlin noise algorithm
     * @throws WorldGenException If the number of octaves is less than or
     * equal to zero
     */
    public void setOctaves(int octaves) throws WorldGenException {
        if (octaves <= 0) {
            throw new WorldGenException("Octaves cannot be less than or equal" +
                    "to zero");
        }
        this.octaves = octaves;
    }

    /**
     * Get's the persistence value used for the Perlin noise algorithm
     * @return The persistence value used in the Perlin noise algorithm
     */
    public float getPersistence() {
        return persistence;
    }

    /**
     * Set's the persistence value used in the Perlin noise generation
     * @param persistence A multiplier that determines how quickly the amplitudes diminish for
     *     // each successive octave in a Perlin-noise function.
     * @throws WorldGenException If the persistence is less than 0 or greater
     * than 1
     */
    public void setPersistence(Float persistence) throws WorldGenException {
        if (persistence <= 0) {
            throw new WorldGenException("Persistence cannot be less than or " +
                    "zero");
        } else if (persistence >= 1) {
            throw new WorldGenException("Persistence cannot be greater than " +
                    "one");
        }
        this.persistence = persistence;
    }

    /**
     * Get's the lacunarity used in the Perlin noise algorithm
     * @return The lacunarity value used in the Perlin noise algorithm
     */
    public float getLacunarity() {
        return lacunarity;
    }

    /**
     * Set's the lacunarity value used in the Perlin noise algorithm
     * @param lacunarity A multiplier that determines how quickly the frequency increases for
     *     // each successive octave in a Perlin-noise function.
     * @throws WorldGenException If the lacunarity is less than one
     */
    public void setLacunarity(float lacunarity) throws WorldGenException {
        if (lacunarity < 1) {
            throw new WorldGenException("Lacunarity cannot be less than one");
        }
        this.lacunarity = lacunarity;
    }

    /**
     * Defines the height values allowed for a specific biome.
     * The key is the biome type and the value is the max height value allowed
     * for that biome
     */
    public void initialiseBiomeHeightMap() {
        this.biomeHeightMap = new EnumMap<>(BiomeType.class);
        this.biomeHeightMap.put(BiomeType.SNOW, 1.0f);
        this.biomeHeightMap.put(BiomeType.MOUNTAIN_ROCKS, 0.85f);
        this.biomeHeightMap.put(BiomeType.TUNDRA, 0.82f);
        this.biomeHeightMap.put(BiomeType.SHRUBLAND, 0.78f);
        this.biomeHeightMap.put(BiomeType.TEMPERATE_RAINFOREST, 0.65f);
        this.biomeHeightMap.put(BiomeType.GRASSLAND, 0.58f);
        this.biomeHeightMap.put(BiomeType.TEMPERATE_DESERT, 0.50f);
        this.biomeHeightMap.put(BiomeType.TROPICAL_RAINFOREST, 0.47f);
        this.biomeHeightMap.put(BiomeType.SUBTROPICAL_DESERT, 0.41f);
        this.biomeHeightMap.put(BiomeType.BEACH, 0.37f);
        this.biomeHeightMap.put(BiomeType.OCEAN, 0.32f);
    }

    /**
     * Get's the height map for each biome within the world
     * @return The height map for each biome
     */
    public Map<BiomeType, Float> getBiomeHeightMap() {
        return this.biomeHeightMap;
    }

    /**
     * Defines the moisture values allowed for a specific biome.
     * The key is the biome type and the value is the min moisture value
     * allowed for that biome
     */
    public void initialiseBiomeMoistureMap() {
        this.biomeMoistureMap = new EnumMap<>(BiomeType.class);
        this.biomeMoistureMap.put(BiomeType.OCEAN, 0.92f);
        this.biomeMoistureMap.put(BiomeType.SNOW, 0.75f);
        this.biomeMoistureMap.put(BiomeType.TEMPERATE_RAINFOREST, 0.70f);
        this.biomeMoistureMap.put(BiomeType.TROPICAL_RAINFOREST, 0.67f);
        this.biomeMoistureMap.put(BiomeType.BEACH, 0.43f);
        this.biomeMoistureMap.put(BiomeType.SHRUBLAND, 0.44f);
        this.biomeMoistureMap.put(BiomeType.TUNDRA, 0.45f);
        this.biomeMoistureMap.put(BiomeType.GRASSLAND, 0.36f);
        this.biomeMoistureMap.put(BiomeType.TEMPERATE_DESERT, 0.21f);
        this.biomeMoistureMap.put(BiomeType.SUBTROPICAL_DESERT, 0.15f);
        this.biomeMoistureMap.put(BiomeType.MOUNTAIN_ROCKS, 0.1f);
    }

    /**
     * Get's the moisture map for each biome within the world
     * @return The moisture map for each biome
     */
    public Map<BiomeType, Float> getBiomeMoistureMap() {
        return this.biomeMoistureMap;
    }

    /**
     * Get's the Map of tiles for the world
     * @return The Map of tiles for the world
     */
    public Map<BiomeType, CopyOnWriteArrayList<Tile>> getMapOfTilesInBiomes() {
        return mapOfTilesInBiomes;
    }

    /**
     * Set's the Map of tiles for the world
     * @param mapOfTilesInBiomes A map of tiles to set for the world
     */
    public void setMapOfTilesInBiomes(Map<BiomeType, CopyOnWriteArrayList<Tile>> mapOfTilesInBiomes) {
        this.mapOfTilesInBiomes = (ConcurrentHashMap<BiomeType, CopyOnWriteArrayList<Tile>>)mapOfTilesInBiomes;
    }

    public void initialiseTileMap() {
        this.mapOfTilesInBiomes = new ConcurrentHashMap<>();
    }
}
